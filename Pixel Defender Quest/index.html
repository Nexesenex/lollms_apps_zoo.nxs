<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Defender Quest - Menu Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            background-color: #2c3e50;
            color: #ecf0f1;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden; /* Prevent scrollbars from menu transitions */
        }

        .main-title {
            color: #f1c40f;
            text-shadow: 3px 3px #e74c3c;
            margin-bottom: 20px;
            font-size: 2em;
            text-align: center;
        }

        /* --- Screen Containers --- */
        .screen {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 700px; /* Max width for menu content */
            padding: 20px;
            box-sizing: border-box;
            background-color: rgba(52, 73, 94, 0.85); /* Slightly transparent Wet asphalt */
            border: 4px solid #bdc3c7; /* Silver */
            box-shadow: 0 0 25px rgba(0,0,0,0.6);
            text-align: center;
        }
        .screen.active {
            display: flex;
        }

        #game-ui-container { /* Specific styling for game area */
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #game-area {
            display: flex;
            gap: 15px;
            align-items: flex-start; /* Align canvas and controls to top */
        }

        canvas {
            border: 3px solid #ecf0f1;
            background-color: #76C7AF;
            cursor: crosshair;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            background-color: #2c3e50;
            border: 2px solid #7f8c8d;
            min-width: 200px;
            max-height: calc(10 * 40px + 6px); /* Match canvas height approx */
            overflow-y: auto;
        }
        
        .control-group { margin-bottom:10px; }
        .control-group h3 {
            font-size: 0.9em; margin-top: 0; margin-bottom: 5px;
            color: #f1c40f; border-bottom: 1px solid #7f8c8d; padding-bottom: 3px;
        }

        /* --- Buttons --- */
        button, .menu-button {
            font-family: 'Press Start 2P', cursive;
            background-color: #3498db;
            color: white;
            border: 2px solid #2980b9;
            padding: 12px 20px;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.9em;
            transition: background-color 0.2s, transform 0.1s;
            display: block;
            width: 100%;
            max-width: 300px; /* Max width for menu buttons */
            margin: 8px auto; /* Centering menu buttons */
            box-sizing: border-box;
        }
        button:hover, .menu-button:hover { background-color: #2980b9; }
        button:active, .menu-button:active { background-color: #1f6390; transform: scale(0.98); }
        
        button.tower-button { /* Specific to in-game tower buttons */
            text-align: left;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px; /* Slightly smaller padding */
            font-size: 0.8em;
            max-width: none; /* Take full width of control panel */
        }
        button.tower-button.selected { background-color: #e67e22; border-color: #d35400; }

        .info-bar { font-size: 0.9em; margin-bottom: 5px; }
        .info-bar span { color: #f1c40f; }

        /* --- Specific Screen Content --- */
        .screen h2 {
            font-size: 1.5em;
            color: #f1c40f;
            margin-bottom: 15px;
        }
        .screen p, .screen li {
            font-size: 0.8em;
            line-height: 1.6;
            text-align: left;
            margin-bottom: 10px;
            max-width: 500px; /* Content width inside screens */
        }
        .screen ul { padding-left: 25px; }

        #highScoreInputArea { margin-bottom: 20px; }
        #highScoreInputArea p { text-align: center; }
        #highScoreInputArea input {
            font-family: 'Press Start 2P', cursive; padding: 8px; margin-right: 5px;
            background-color: #555; border: 1px solid #777; color: #fff; text-align: center;
        }

        #highscores-list-container {
            font-size: 0.8em;
            text-align: center;
            width: 100%;
            max-width: 300px;
        }
        #highscores-list-container h3 {
            margin-top:0; margin-bottom: 10px; font-size: 1em; color: #1abc9c;
        }
        #highscores-list-container ol { padding-left: 20px; margin:0; list-style-position: inside;}
        #highscores-list-container li { margin-bottom: 5px; text-align: left;}
        #highscores-list-container li span { color: #f1c40f; float: right;}

        /* For End Game overlay specifically */
        #end-game-overlay h2 { font-size: 1.8em; }
        #end-game-overlay p { font-size: 1em; text-align:center; }


    </style>
</head>
<body>
    <h1 class="main-title">Pixel Defender Quest</h1>

    <!-- Main Menu Screen -->
    <div id="main-menu" class="screen active">
        <h2>Main Menu</h2>
        <button id="startGameBtn" class="menu-button">Start Game</button>
        <button id="viewHighScoresBtn" class="menu-button">High Scores</button>
        <button id="helpBtn" class="menu-button">Help</button>
        <button id="creditsBtn" class="menu-button">Credits</button>
    </div>

    <!-- Game UI Container (Canvas + Controls) -->
    <div id="game-ui-container" class="screen">
        <div id="game-area">
            <canvas id="gameCanvas"></canvas>
            <div id="controls">
                <div class="control-group">
                    <h3>Status</h3>
                    <div class="info-bar">Gold: <span id="gold">100</span></div>
                    <div class="info-bar">Lives: <span id="lives">20</span></div>
                    <div class="info-bar">Level: <span id="level">1</span> / <span id="maxLevel">25</span></div>
                    <div class="info-bar">Wave: <span id="wave">0</span> / <span id="maxWaveInLevel">0</span></div>
                    <div class="info-bar">Score: <span id="score">0</span></div>
                </div>
                <div class="control-group">
                    <h3>Towers</h3>
                    <button class="tower-button" id="selectTurret" data-type="turret">
                        <span>Turret</span><span>(50G)</span>
                    </button>
                    <button class="tower-button" id="selectCannon" data-type="cannon">
                        <span>Cannon</span><span>(120G)</span>
                    </button>
                     <button class="tower-button" id="selectFreezer" data-type="freezer">
                        <span>Freezer</span><span>(80G)</span>
                    </button>
                </div>
                <div class="control-group">
                    <h3>Game</h3>
                    <button id="startWaveButton">Start Wave</button>
                    <p id="waveInfo" style="font-size:0.7em; margin-top:5px;"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Help Screen -->
    <div id="help-screen" class="screen">
        <h2>How to Play</h2>
        <p>Welcome to Pixel Defender Quest! Your goal is to stop the waves of pixel invaders from reaching the end of the path on the right side of the screen.</p>
        <ul>
            <li><strong>Placing Towers:</strong> Select a tower from the "Towers" panel on the right. Click on an empty green square on the game grid to place it. Towers cost gold!</li>
            <li><strong>Gold:</strong> Earn gold by defeating invaders and clearing waves/levels. Use gold to buy more towers.</li>
            <li><strong>Lives:</strong> You start with 20 lives. Each invader that reaches the end of the path costs you one life. If lives reach 0, the game is over.</li>
            <li><strong>Waves:</strong> Click "Start Wave" to begin the next onslaught. Survive all waves in a level to advance.</li>
            <li><strong>Tower Types:</strong>
                <ul>
                    <li>Turret: Basic all-around attacker.</li>
                    <li>Cannon: Slower, but deals high damage.</li>
                    <li>Freezer: Low damage, but slows down enemies it hits.</li>
                </ul>
            </li>
            <li><strong>Strategy:</strong> Place towers strategically to cover the path effectively. Different tower combinations work best against different enemy types and path layouts.</li>
        </ul>
        <button id="helpBackBtn" class="menu-button">Back to Menu</button>
    </div>

    <!-- Credits Screen -->
    <div id="credits-screen" class="screen">
        <h2>Credits</h2>
        <p><strong>Game Concept & Design:</strong> ParisNeo</p>
        <p><strong>Core Engineering & AI Assistance:</strong> Gemini (Model by Google)</p>
        <p><strong>Font:</strong> "Press Start 2P" by CodeMan38 (via Google Fonts)</p>
        <p>Thanks for playing!</p>
        <button id="creditsBackBtn" class="menu-button">Back to Menu</button>
    </div>

    <!-- High Scores Screen -->
    <div id="highscores-screen" class="screen">
        <h2>High Scores</h2>
        <div id="highscores-list-container">
            <ol id="highScoreListDisplay"></ol>
        </div>
        <button id="highScoresBackBtn" class="menu-button">Back to Menu</button>
    </div>

    <!-- End Game Message Overlay -->
    <div id="end-game-overlay" class="screen">
        <h2 id="message-title">Game Over!</h2>
        <p id="message-text">You ran out of lives!</p>
        <div id="highScoreInputArea" style="display:none;">
            <p>New High Score! Enter 3 initials:</p>
            <input type="text" id="playerNameInput" maxlength="3" size="3">
            <button id="submitScoreButton">OK</button>
        </div>
        <button id="endGameBackToMenuBtn" class="menu-button">Back to Menu</button>
    </div>

    <script>
        // --- Get DOM Elements ---
        const mainMenuScreen = document.getElementById('main-menu');
        const gameUiContainer = document.getElementById('game-ui-container');
        const helpScreen = document.getElementById('help-screen');
        const creditsScreen = document.getElementById('credits-screen');
        const highScoresScreen = document.getElementById('highscores-screen');
        const endGameOverlay = document.getElementById('end-game-overlay');

        const startGameBtn = document.getElementById('startGameBtn');
        const viewHighScoresBtn = document.getElementById('viewHighScoresBtn');
        const helpBtn = document.getElementById('helpBtn');
        const creditsBtn = document.getElementById('creditsBtn');
        const helpBackBtn = document.getElementById('helpBackBtn');
        const creditsBackBtn = document.getElementById('creditsBackBtn');
        const highScoresBackBtn = document.getElementById('highScoresBackBtn');
        const endGameBackToMenuBtn = document.getElementById('endGameBackToMenuBtn');
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const goldDisplay = document.getElementById('gold');
        const livesDisplay = document.getElementById('lives');
        const levelDisplay = document.getElementById('level');
        const maxLevelDisplay = document.getElementById('maxLevel');
        const waveDisplay = document.getElementById('wave');
        const maxWaveInLevelDisplay = document.getElementById('maxWaveInLevel');
        const scoreDisplay = document.getElementById('score');
        const startWaveButton = document.getElementById('startWaveButton');
        const waveInfoDisplay = document.getElementById('waveInfo');
        
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const highScoreInputArea = document.getElementById('highScoreInputArea');
        const playerNameInput = document.getElementById('playerNameInput');
        const submitScoreButton = document.getElementById('submitScoreButton');
        const highScoreListDisplay = document.getElementById('highScoreListDisplay');

        // --- Game Constants & Variables ---
        const TILE_SIZE = 40;
        const GRID_WIDTH = 15;
        const GRID_HEIGHT = 10;
        canvas.width = GRID_WIDTH * TILE_SIZE;
        canvas.height = GRID_HEIGHT * TILE_SIZE;

        let gold, lives, currentLevel, score, currentWaveInLevel;
        const MAX_LEVELS = 25;
        let wavesForCurrentLevel = [];
        let enemies = [], towers = [], projectiles = [];
        let selectedTowerType = null;
        let waveInProgress = false;
        let enemiesThisWave, enemiesSpawnedThisWave, enemiesThisWavePlus, enemiesSpawnedThisWavePlus;
        let spawnInterval, spawnIntervalPlus, lastSpawnTime, lastSpawnTimePlus;
        
        let gameOver = false;
        let gameWon = false;

        let path = []; 
        let currentLevelPrng;
        let audioContext;
        let gameLoopAnimationId = null;

        // --- Game State Management ---
        let gameState = 'MENU';

        function switchScreen(targetScreenId) {
            document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
            document.getElementById(targetScreenId).classList.add('active');
            
            if (targetScreenId === 'main-menu') gameState = 'MENU';
            else if (targetScreenId === 'help-screen') gameState = 'HELP';
            else if (targetScreenId === 'credits-screen') gameState = 'CREDITS';
            else if (targetScreenId === 'highscores-screen') gameState = 'HIGHSCORES';
        }

        // --- Tower & Enemy Definitions ---
        const towerTypes = {
            turret: { cost: 50, range: TILE_SIZE * 2.5, damage: 15, fireRate: 1000, color: '#3498db', projectileColor: '#5dade2', projectileSpeed: 5, projectileSize: 3 },
            cannon: { cost: 120, range: TILE_SIZE * 2, damage: 50, fireRate: 2000, color: '#e74c3c', projectileColor: '#c0392b', projectileSpeed: 4, projectileSize: 5 },
            freezer: { cost: 80, range: TILE_SIZE * 1.8, damage: 5, fireRate: 1500, color: '#1abc9c', projectileColor: '#A2D0F5', projectileSpeed: 6, projectileSize: 4, slowFactor: 0.5, slowDuration: 2000 }
        };
        const enemyTypes = {
            basic: { health: 50, speed: 0.8, color: '#9b59b6', size: TILE_SIZE * 0.4, goldValue: 5 },
            fast: { health: 30, speed: 1.5, color: '#f1c40f', size: TILE_SIZE * 0.3, goldValue: 7 },
            strong: { health: 150, speed: 0.5, color: '#2ecc71', size: TILE_SIZE * 0.5, goldValue: 10 },
            boss: { health: 500, speed: 0.4, color: '#7f8c8d', size: TILE_SIZE * 0.7, goldValue: 50}
        };

        // --- PRNG, Level/Wave Generation, Audio ---
        function mulberry32(a) { 
            return function() { var t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }
        }
        function getWavesForLevel(levelNum) {
            const waves = [];
            const difficultyMultiplier = 1 + (levelNum -1) * 0.15; 
            const enemyHealthMultiplier = 1 + (levelNum-1) * 0.1;
            const enemySpeedMultiplier = 1 + (levelNum-1) * 0.05;
            const baseEnemies = JSON.parse(JSON.stringify(enemyTypes)); 
            Object.keys(baseEnemies).forEach(key => {
                baseEnemies[key].health = Math.floor(enemyTypes[key].health * enemyHealthMultiplier);
                baseEnemies[key].speed = parseFloat((enemyTypes[key].speed * enemySpeedMultiplier).toFixed(1));
            });

            waves.push({ 
                count: Math.floor((5 + levelNum) * difficultyMultiplier * 0.7), 
                type: 'basic', 
                interval: Math.max(400, 1200 - levelNum * 30),
                enemyStats: baseEnemies 
            });

            let type2 = (levelNum % 3 === 0) ? 'strong' : 'fast';
            waves.push({ 
                count: Math.floor((3 + levelNum) * difficultyMultiplier * 0.6), 
                type: 'basic', 
                interval: Math.max(350, 1100 - levelNum * 25),
                plus: { 
                    count: Math.floor((2 + Math.floor(levelNum/2)) * difficultyMultiplier * 0.5), 
                    type: type2, 
                    interval: Math.max(500, 1300 - levelNum * 20),
                    enemyStats: baseEnemies // Fixed: Added enemyStats here
                },
                enemyStats: baseEnemies
            });
            
            let type3 = (levelNum % 5 === 0 && levelNum >=5) ? 'boss' : ((levelNum % 2 === 0) ? 'strong' : 'fast');
            let count3_main = (type3 === 'boss') ? Math.max(1, Math.floor(levelNum / 7)) : Math.floor((4 + levelNum) * difficultyMultiplier * 0.5);
            
            waves.push({
                count: count3_main,
                type: type3,
                interval: Math.max(600, (type3 === 'boss' ? 2500 : 1500) - levelNum * 20),
                plus: (type3 !== 'boss' ? {
                    count: Math.floor((3 + levelNum) * difficultyMultiplier * 0.4),
                    type: 'basic',
                    interval: Math.max(300, 900 - levelNum * 15),
                    enemyStats: baseEnemies // Fixed: Added enemyStats here
                } : null),
                enemyStats: baseEnemies
            });
            
            if (levelNum > 15 && levelNum % 4 === 0) { 
                 waves.push({ 
                    count: Math.floor((10 + levelNum) * difficultyMultiplier * 0.8), 
                    type: 'fast', 
                    interval: Math.max(200, 700 - levelNum * 10),
                    enemyStats: baseEnemies
                });
            }
            return waves;
        }
        function generateLevelPath(levelSeed) { 
            currentLevelPrng = mulberry32(levelSeed + 1000); 
            path = [];
            const tempGrid = Array(GRID_HEIGHT).fill(null).map(() => Array(GRID_WIDTH).fill(false));
            let startY = Math.floor(currentLevelPrng() * (GRID_HEIGHT - 2)) + 1; 
            let currentX = 0; let currentY = startY;
            path.push({ x: currentX, y: currentY }); tempGrid[currentY][currentX] = true;
            let attempts = 0; const maxAttempts = GRID_WIDTH * GRID_HEIGHT * 2; 
            while (currentX < GRID_WIDTH - 1 && attempts < maxAttempts) {
                attempts++; let possibleMoves = [];
                if (currentX + 1 < GRID_WIDTH && !tempGrid[currentY][currentX + 1]) possibleMoves.push({ x: currentX + 1, y: currentY, weight: 4 });
                if (currentY + 1 < GRID_HEIGHT && !tempGrid[currentY + 1][currentX]) possibleMoves.push({ x: currentX, y: currentY + 1, weight: 2 });
                if (currentY - 1 >= 0 && !tempGrid[currentY - 1][currentX]) possibleMoves.push({ x: currentX, y: currentY - 1, weight: 2 });
                if (currentX > 1 && currentX -1 >=0 && !tempGrid[currentY][currentX-1] && currentLevelPrng() < 0.15 && path.length > 3) possibleMoves.push({x: currentX-1, y: currentY, weight: 1});
                if (possibleMoves.length === 0) {
                    if (path.length > 1 && currentLevelPrng() < 0.8) { path.pop(); if (path.length > 0) { const prev = path[path.length -1]; currentX = prev.x; currentY = prev.y; continue; } else { break; }}
                    else { if (currentX + 1 < GRID_WIDTH && !tempGrid[currentY][currentX + 1]) { currentX++; } else if (currentY + 1 < GRID_HEIGHT && !tempGrid[currentY + 1][currentX]) { currentY++; } else if (currentY - 1 >= 0 && !tempGrid[currentY - 1][currentX]) { currentY--; } else { break; } if (!tempGrid[currentY][currentX]) { path.push({ x: currentX, y: currentY }); tempGrid[currentY][currentX] = true; } continue; }
                }
                const totalWeight = possibleMoves.reduce((sum, move) => sum + move.weight, 0);
                let randomPick = currentLevelPrng() * totalWeight; let chosenMove;
                for (const move of possibleMoves) { if (randomPick < move.weight) { chosenMove = move; break; } randomPick -= move.weight; }
                currentX = chosenMove.x; currentY = chosenMove.y; path.push({ x: currentX, y: currentY }); tempGrid[currentY][currentX] = true;
            }
            while(currentX < GRID_WIDTH - 1) {
                currentX++; if (!tempGrid[currentY][currentX]) { path.push({x: currentX, y: currentY}); tempGrid[currentY][currentX] = true; }
                else { let newY = currentY; if (currentY + 1 < GRID_HEIGHT && !tempGrid[currentY+1][currentX]) newY = currentY+1; else if (currentY - 1 >= 0 && !tempGrid[currentY-1][currentX]) newY = currentY-1; currentY = newY; if (!tempGrid[currentY][currentX]) { path.push({x: currentX, y: currentY}); tempGrid[currentY][currentX] = true; }}
            }
        }
        function initAudio() { 
            if (!audioContext && (window.AudioContext || window.webkitAudioContext)) { audioContext = new (window.AudioContext || window.webkitAudioContext)(); }
        }
        function playSound(type, options = {}) { 
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator(); const gainNode = audioContext.createGain(); oscillator.connect(gainNode); gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(options.volume || 0.1, audioContext.currentTime);
            switch(type) {
                case 'waveStart': oscillator.type = 'sawtooth'; oscillator.frequency.setValueAtTime(200, audioContext.currentTime); oscillator.frequency.linearRampToValueAtTime(500, audioContext.currentTime + 0.4); gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.6); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.6); break;
                case 'enemyDefeat': oscillator.type = 'triangle'; oscillator.frequency.setValueAtTime(options.freq || 250, audioContext.currentTime); oscillator.frequency.exponentialRampToValueAtTime((options.freq || 250) * 0.5, audioContext.currentTime + 0.15); gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.15); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.15); break;
                case 'projectile': oscillator.type = options.oscType || 'triangle'; oscillator.frequency.setValueAtTime(options.freq || 700, audioContext.currentTime); if (options.freqRamp) { oscillator.frequency.exponentialRampToValueAtTime(options.freqRamp, audioContext.currentTime + (options.duration || 0.08)); } gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + (options.duration || 0.08)); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + (options.duration || 0.08)); break;
                case 'placeTower': oscillator.type = 'square'; oscillator.frequency.setValueAtTime(150, audioContext.currentTime); oscillator.frequency.linearRampToValueAtTime(100, audioContext.currentTime + 0.1); gainNode.gain.setValueAtTime(0.15, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.1); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.1); break;
                case 'error': oscillator.type = 'sawtooth'; oscillator.frequency.setValueAtTime(100, audioContext.currentTime); gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.2); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.2); break;
            }
        }

        // --- Drawing Functions ---
        function drawGrid() { 
            ctx.strokeStyle = '#6AAB9C'; ctx.lineWidth = 0.5;
            for (let x = 0; x < GRID_WIDTH; x++) { for (let y = 0; y < GRID_HEIGHT; y++) { ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE); } }
        }
        function drawPath() {
            if (!path || path.length === 0) return;
            ctx.fillStyle = '#D2B48C'; ctx.strokeStyle = '#8C6D46'; ctx.lineWidth = 2;
            path.forEach(p => { ctx.fillRect(p.x * TILE_SIZE, p.y * TILE_SIZE, TILE_SIZE, TILE_SIZE); ctx.strokeRect(p.x * TILE_SIZE, p.y * TILE_SIZE, TILE_SIZE, TILE_SIZE); });
        }
        function drawTowers() { 
            towers.forEach(tower => {
                ctx.fillStyle = tower.type.color; ctx.fillRect( tower.x * TILE_SIZE + TILE_SIZE * 0.15, tower.y * TILE_SIZE + TILE_SIZE * 0.15, TILE_SIZE * 0.7, TILE_SIZE * 0.7 );
                ctx.save(); ctx.translate(tower.x * TILE_SIZE + TILE_SIZE / 2, tower.y * TILE_SIZE + TILE_SIZE / 2); ctx.rotate(tower.angle || 0);
                ctx.fillStyle = 'grey'; ctx.fillRect(-TILE_SIZE * 0.1, -TILE_SIZE * 0.35, TILE_SIZE * 0.2, TILE_SIZE * 0.35); ctx.restore();
            });
        }
        function drawEnemies() { 
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.isSlowed ? '#ADD8E6' : enemy.currentStats.color; const size = enemy.currentStats.size * (enemy.isSlowed ? 0.8 : 1);
                ctx.beginPath(); ctx.arc(enemy.x, enemy.y, size, 0, Math.PI * 2); ctx.fill();
                const healthBarWidth = TILE_SIZE * 0.6; const healthBarHeight = 5;
                ctx.fillStyle = 'red'; ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - size - healthBarHeight - 2, healthBarWidth, healthBarHeight);
                ctx.fillStyle = 'lime'; ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - size - healthBarHeight - 2, healthBarWidth * (enemy.health / enemy.maxHealth), healthBarHeight);
            });
        }
        function drawProjectiles() {
            projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); });
        }
        function drawPlacementPreview(event) { 
            if (!selectedTowerType) return;
            const rect = canvas.getBoundingClientRect(); const mouseX = event.clientX - rect.left; const mouseY = event.clientY - rect.top;
            const gridX = Math.floor(mouseX / TILE_SIZE); const gridY = Math.floor(mouseY / TILE_SIZE);
            if (gridX < 0 || gridX >= GRID_WIDTH || gridY < 0 || gridY >= GRID_HEIGHT) return;
            const towerData = towerTypes[selectedTowerType]; let canPlace = true;
            const onPath = path.some(p => p.x === gridX && p.y === gridY);
            const occupied = towers.some(t => t.x === gridX && t.y === gridY);
            if (onPath || occupied || gold < towerData.cost) canPlace = false;
            ctx.globalAlpha = 0.5; ctx.fillStyle = canPlace ? towerData.color : 'rgba(255,0,0,0.5)';
            ctx.fillRect(gridX * TILE_SIZE, gridY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.beginPath(); ctx.arc(gridX * TILE_SIZE + TILE_SIZE / 2, gridY * TILE_SIZE + TILE_SIZE / 2, towerData.range, 0, Math.PI * 2);
            ctx.strokeStyle = canPlace ? 'rgba(255,255,255,0.8)' : 'rgba(200,0,0,0.8)'; ctx.lineWidth = 2; ctx.stroke();
            ctx.globalAlpha = 1.0; ctx.lineWidth = 0.5; 
        }

        // --- UI Update (in-game) ---
        function updateUI() { 
            goldDisplay.textContent = gold; livesDisplay.textContent = lives; levelDisplay.textContent = currentLevel;
            maxLevelDisplay.textContent = MAX_LEVELS; waveDisplay.textContent = currentWaveInLevel; maxWaveInLevelDisplay.textContent = wavesForCurrentLevel.length;
            scoreDisplay.textContent = score;
            document.querySelectorAll('.tower-button').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.type === selectedTowerType);
                const towerData = towerTypes[btn.dataset.type]; btn.disabled = gold < towerData.cost;
                btn.style.opacity = (gold < towerData.cost) ? "0.5" : "1";
            });
            startWaveButton.disabled = waveInProgress || gameOver || gameWon || currentWaveInLevel >= wavesForCurrentLevel.length;
            startWaveButton.style.opacity = startWaveButton.disabled ? "0.5" : "1";
            if (!waveInProgress && currentWaveInLevel < wavesForCurrentLevel.length && !gameOver && !gameWon) {
                const nextWaveData = wavesForCurrentLevel[currentWaveInLevel]; let infoText = `Next: ${nextWaveData.count} ${nextWaveData.type}(s)`;
                if (nextWaveData.plus) infoText += ` & ${nextWaveData.plus.count} ${nextWaveData.plus.type}(s)`;
                waveInfoDisplay.textContent = infoText;
            } else if (currentWaveInLevel >= wavesForCurrentLevel.length && enemies.length === 0 && !waveInProgress && !gameOver && !gameWon) {
                 waveInfoDisplay.textContent = "Level Cleared! Next Level...";
            } else if (gameWon) { waveInfoDisplay.textContent = "ALL LEVELS CLEARED!"; } else { waveInfoDisplay.textContent = ""; }
        }

        // --- Game Logic ---
        function placeTower(event) { 
            if (!selectedTowerType || gameOver || gameWon) return; initAudio(); 
            const rect = canvas.getBoundingClientRect(); const clickX = event.clientX - rect.left; const clickY = event.clientY - rect.top;
            const gridX = Math.floor(clickX / TILE_SIZE); const gridY = Math.floor(clickY / TILE_SIZE);
            const towerData = towerTypes[selectedTowerType];
            if (gold >= towerData.cost) {
                const onPath = path.some(p => p.x === gridX && p.y === gridY);
                const occupied = towers.some(t => t.x === gridX && t.y === gridY);
                if (!onPath && !occupied && gridX < GRID_WIDTH && gridY < GRID_HEIGHT && gridX >=0 && gridY >=0) {
                    towers.push({ x: gridX, y: gridY, type: towerData, lastShotTime: 0, angle: 0 });
                    gold -= towerData.cost; playSound('placeTower'); updateUI();
                } else { playSound('error'); console.log("Cannot place tower: on path or occupied."); }
            } else { playSound('error'); console.log("Not enough gold."); }
        }
        function spawnEnemy(waveInfo, isPlus = false) {
            if (path.length === 0) return; 
            const enemyTypeKey = waveInfo.type; 
            // Ensure waveInfo.enemyStats exists. This was the source of the bug.
            if (!waveInfo.enemyStats) {
                console.error("CRITICAL: waveInfo.enemyStats is undefined!", "waveInfo:", waveInfo, "isPlus:", isPlus);
                // Fallback or skip spawning this enemy to prevent a hard crash.
                // A more robust solution might be to fetch from a global or default if this happens.
                // For now, just log and return.
                return; 
            }
            const baseStats = waveInfo.enemyStats[enemyTypeKey]; 
            if (!baseStats) { 
                console.error("Undefined enemy type in wave data:", enemyTypeKey, "Available stats:", waveInfo.enemyStats); 
                return; 
            }
            enemies.push({ 
                x: path[0].x * TILE_SIZE + TILE_SIZE / 2, 
                y: path[0].y * TILE_SIZE + TILE_SIZE / 2, 
                pathIndex: 0, 
                currentStats: baseStats, 
                health: baseStats.health, 
                maxHealth: baseStats.health, 
                speed: baseStats.speed, 
                baseSpeed: baseStats.speed, 
                isSlowed: false, 
                slowTimer: 0, 
                id: Math.random() 
            });
            if (!isPlus) enemiesSpawnedThisWave++; else enemiesSpawnedThisWavePlus++;
         }
        function startNextWave() { 
            if (waveInProgress || currentWaveInLevel >= wavesForCurrentLevel.length || gameOver || gameWon) return;
            initAudio(); currentWaveInLevel++; waveInProgress = true; enemiesSpawnedThisWave = 0; enemiesSpawnedThisWavePlus = 0;
            lastSpawnTime = 0; lastSpawnTimePlus = 0;
            const waveData = wavesForCurrentLevel[currentWaveInLevel - 1]; 
            if (!waveData) { console.error("Error: No wave data for current wave " + currentWaveInLevel); return; }
            enemiesThisWave = waveData.count; spawnInterval = waveData.interval;
            if (waveData.plus) { 
                enemiesThisWavePlus = waveData.plus.count; 
                spawnIntervalPlus = waveData.plus.interval; 
            } else { 
                enemiesThisWavePlus = 0; 
            }
            playSound('waveStart'); updateUI();
        }
        function updateEnemies(deltaTime) { 
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (enemy.isSlowed) { enemy.slowTimer -= deltaTime; if (enemy.slowTimer <= 0) { enemy.isSlowed = false; enemy.speed = enemy.baseSpeed; }}
                if (path.length === 0 || enemy.pathIndex + 1 >= path.length) { 
                    enemies.splice(i, 1); lives--; updateUI(); 
                    if (lives <= 0 && !gameOver) { handleEndGame(false); } 
                    continue; 
                }
                const targetWaypoint = path[enemy.pathIndex + 1]; 
                const targetX = targetWaypoint.x * TILE_SIZE + TILE_SIZE / 2; 
                const targetY = targetWaypoint.y * TILE_SIZE + TILE_SIZE / 2;
                const dx = targetX - enemy.x; const dy = targetY - enemy.y; 
                const distance = Math.sqrt(dx * dx + dy * dy); 
                const moveSpeed = enemy.speed * (deltaTime/16); // Assuming 60FPS base for speed
                if (distance < moveSpeed ) { 
                    enemy.pathIndex++; 
                    if (enemy.pathIndex >= path.length -1) { 
                        enemies.splice(i, 1); lives--; updateUI(); 
                        if (lives <= 0 && !gameOver) { handleEndGame(false); } 
                        continue; 
                    }
                } else { 
                    enemy.x += (dx / distance) * moveSpeed; 
                    enemy.y += (dy / distance) * moveSpeed; 
                }
            }
        }
        function updateTowers(currentTime, deltaTime) {
            towers.forEach(tower => {
                if (currentTime - tower.lastShotTime > tower.type.fireRate) {
                    let target = null; let minDistanceToEnd = Infinity;
                    enemies.forEach(enemy => {
                        const dxt = (tower.x * TILE_SIZE + TILE_SIZE / 2) - enemy.x; 
                        const dyt = (tower.y * TILE_SIZE + TILE_SIZE / 2) - enemy.y;
                        const distanceToTower = Math.sqrt(dxt * dxt + dyt * dyt);
                        if (distanceToTower <= tower.type.range) {
                            let distanceToEnd = 0; 
                            for(let j = enemy.pathIndex; j < path.length -1; j++) { 
                                const p1 = path[j], p2 = path[j+1]; 
                                distanceToEnd += Math.sqrt(Math.pow((p2.x-p1.x)*TILE_SIZE,2) + Math.pow((p2.y-p1.y)*TILE_SIZE,2)); 
                            }
                            if (enemy.pathIndex < path.length - 1) { 
                                const nextWpX = path[enemy.pathIndex + 1].x * TILE_SIZE + TILE_SIZE / 2; 
                                const nextWpY = path[enemy.pathIndex + 1].y * TILE_SIZE + TILE_SIZE / 2; 
                                distanceToEnd += Math.sqrt(Math.pow(nextWpX - enemy.x, 2) + Math.pow(nextWpY - enemy.y, 2));
                            }
                            if (distanceToEnd < minDistanceToEnd) { minDistanceToEnd = distanceToEnd; target = enemy; }
                        }
                    });
                    if (target) {
                        const angle = Math.atan2( target.y - (tower.y * TILE_SIZE + TILE_SIZE / 2), target.x - (tower.x * TILE_SIZE + TILE_SIZE / 2) );
                        tower.angle = angle + Math.PI / 2; 
                        projectiles.push({ 
                            x: tower.x * TILE_SIZE + TILE_SIZE / 2, 
                            y: tower.y * TILE_SIZE + TILE_SIZE / 2, 
                            target: target, 
                            speed: tower.type.projectileSpeed, 
                            damage: tower.type.damage, 
                            color: tower.type.projectileColor, 
                            size: tower.type.projectileSize, 
                            originTowerTypeKey: Object.keys(towerTypes).find(key => towerTypes[key] === tower.type) 
                        });
                        tower.lastShotTime = currentTime;
                        let soundOpts = { freq: 700, duration: 0.08, oscType: 'triangle', freqRamp: 350 };
                        if (tower.type === towerTypes.cannon) soundOpts = { freq: 200, duration: 0.15, oscType: 'square', volume: 0.15 };
                        if (tower.type === towerTypes.freezer) soundOpts = { freq: 1200, duration: 0.1, oscType: 'sine', freqRamp: 900, volume: 0.08 };
                        playSound('projectile', soundOpts);
                    }
                }
            });
        }
        function updateProjectiles(deltaTime) { 
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i]; 
                if (!p.target || p.target.health <= 0 || !enemies.includes(p.target)) { 
                    projectiles.splice(i,1); 
                    continue; 
                }
                const dx = p.target.x - p.x; const dy = p.target.y - p.y; 
                const distance = Math.sqrt(dx * dx + dy * dy); 
                const moveSpeed = p.speed * (deltaTime/16);
                if (distance < moveSpeed + p.target.currentStats.size/2) { 
                    p.target.health -= p.damage;
                    if (p.originTowerTypeKey === 'freezer') { 
                        const freezerData = towerTypes.freezer; 
                        p.target.isSlowed = true; 
                        p.target.speed = p.target.baseSpeed * (1 - freezerData.slowFactor); 
                        p.target.slowTimer = freezerData.slowDuration; 
                    }
                    if (p.target.health <= 0) {
                        const enemyIdx = enemies.indexOf(p.target);
                        if (enemyIdx > -1) { 
                            gold += enemies[enemyIdx].currentStats.goldValue; 
                            score += enemies[enemyIdx].currentStats.goldValue * 10; 
                            playSound('enemyDefeat', {freq: enemies[enemyIdx].currentStats.size > TILE_SIZE * 0.6 ? 150: 250, volume: 0.08}); 
                            enemies.splice(enemyIdx, 1); 
                            updateUI(); 
                        }
                    }
                    projectiles.splice(i, 1);
                } else { 
                    p.x += (dx / distance) * moveSpeed; 
                    p.y += (dy / distance) * moveSpeed; 
                }
            }
        }
        function handleWaveSpawning(currentTime) { 
            if (!waveInProgress || gameOver || gameWon) return;
            const waveData = wavesForCurrentLevel[currentWaveInLevel - 1]; 
            if (!waveData) return; // Should be caught by startNextWave
            if (enemiesSpawnedThisWave < enemiesThisWave && currentTime - lastSpawnTime > spawnInterval) { 
                spawnEnemy(waveData); // Main enemy
                lastSpawnTime = currentTime; 
            }
            if (waveData.plus && enemiesSpawnedThisWavePlus < enemiesThisWavePlus && currentTime - lastSpawnTimePlus > spawnIntervalPlus) { 
                spawnEnemy(waveData.plus, true); // Plus enemy
                lastSpawnTimePlus = currentTime; 
            }
            if (enemiesSpawnedThisWave >= enemiesThisWave && 
               (!waveData.plus || enemiesSpawnedThisWavePlus >= enemiesThisWavePlus) && 
               enemies.length === 0) {
                waveInProgress = false; 
                gold += 25 + currentWaveInLevel * 5 + currentLevel * 5; 
                score += 50 + currentWaveInLevel * 10 + currentLevel * 10;
                if (currentWaveInLevel >= wavesForCurrentLevel.length) { 
                    handleLevelCleared(); 
                } 
                updateUI();
            }
        }
        function handleLevelCleared() {
            gold += 100 + currentLevel * 20; score += 200 + currentLevel * 50; currentLevel++;
            if (currentLevel > MAX_LEVELS) { 
                handleEndGame(true); // Game won
            } else { 
                setupNextLevel(); 
            } 
            updateUI();
        }
        function setupNextLevel() {
            currentWaveInLevel = 0; gold += 50 + currentLevel * 5; projectiles = []; 
            generateLevelPath(currentLevel); wavesForCurrentLevel = getWavesForLevel(currentLevel); 
            updateUI();
        }
        
        // --- High Score Logic ---
        function getHighScores() { const scores = localStorage.getItem('pixelDefenderHighScores'); return scores ? JSON.parse(scores) : []; }
        function saveHighScores(scores) { scores.sort((a, b) => b.score - a.score); localStorage.setItem('pixelDefenderHighScores', JSON.stringify(scores.slice(0, 5))); }
        
        function displayHighScoresOnScreen() {
            const scores = getHighScores();
            highScoreListDisplay.innerHTML = '';
            if (scores.length === 0) {
                highScoreListDisplay.innerHTML = "<li>No scores yet! Be the first!</li>";
            } else {
                scores.forEach(scoreItem => {
                    const li = document.createElement('li');
                    li.textContent = `${scoreItem.name}: `;
                    const scoreSpan = document.createElement('span');
                    scoreSpan.textContent = scoreItem.score;
                    li.appendChild(scoreSpan);
                    highScoreListDisplay.appendChild(li);
                });
            }
        }
        
        let scoreSubmitted = false; 
        function checkAndPromptForHighScore() { 
            scoreSubmitted = false; const highScores = getHighScores();
            if (score > 0 && (highScores.length < 5 || score > highScores[highScores.length - 1].score)) {
                highScoreInputArea.style.display = 'block'; playerNameInput.value = "YOU"; playerNameInput.focus();
            } else {
                 highScoreInputArea.style.display = 'none';
            }
        }
        submitScoreButton.addEventListener('click', () => {
            if(scoreSubmitted) return;
            const name = playerNameInput.value.trim().toUpperCase().substring(0,3) || "AAA";
            const highScores = getHighScores(); highScores.push({ name, score });
            saveHighScores(highScores); 
            highScoreInputArea.style.display = 'none'; scoreSubmitted = true;
        });

        // --- Game State Control ---
        function resetGameVariables() {
            gold = 150; lives = 20; currentLevel = 1; score = 0; currentWaveInLevel = 0;
            enemies = []; towers = []; projectiles = [];
            selectedTowerType = null; waveInProgress = false;
            gameOver = false; gameWon = false; scoreSubmitted = false;
            
            generateLevelPath(currentLevel);
            wavesForCurrentLevel = getWavesForLevel(currentLevel);
        }

        function startGameFlow() {
            initAudio(); 
            gameState = 'PLAYING';
            resetGameVariables();
            switchScreen('game-ui-container');
            updateUI();
            if (gameLoopAnimationId) cancelAnimationFrame(gameLoopAnimationId);
            lastTime = performance.now(); 
            gameLoopAnimationId = requestAnimationFrame(gameLoop);
        }

        function handleEndGame(won) {
            gameState = 'END_GAME';
            gameOver = !won; 
            gameWon = won; 

            if (gameLoopAnimationId) {
                cancelAnimationFrame(gameLoopAnimationId);
                gameLoopAnimationId = null;
            }
            
            if (won) {
                messageTitle.textContent = "VICTORY!"; messageTitle.style.color = "#2ecc71";
                messageText.textContent = `All ${MAX_LEVELS} levels cleared! Final Score: ${score}`;
            } else {
                messageTitle.textContent = "Game Over!"; messageTitle.style.color = "#e74c3c";
                messageText.textContent = `Invaders broke through at Level ${currentLevel}, Wave ${currentWaveInLevel}! Score: ${score}`;
            }
            checkAndPromptForHighScore();
            switchScreen('end-game-overlay');
        }

        // --- Main Game Loop ---
        let lastTime = 0;
        function gameLoop(currentTime) {
            if (gameState !== 'PLAYING' || gameOver || gameWon) { 
                if (gameLoopAnimationId) cancelAnimationFrame(gameLoopAnimationId);
                gameLoopAnimationId = null;
                return; 
            }

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawPath(); drawGrid();
            
            updateEnemies(deltaTime);
            updateTowers(currentTime, deltaTime);
            updateProjectiles(deltaTime);
            handleWaveSpawning(currentTime);

            drawTowers(); drawEnemies(); drawProjectiles();
            updateUI();
            gameLoopAnimationId = requestAnimationFrame(gameLoop);
        }
        
        // --- Menu Navigation Event Listeners ---
        startGameBtn.addEventListener('click', startGameFlow);
        viewHighScoresBtn.addEventListener('click', () => {
            displayHighScoresOnScreen(); 
            switchScreen('highscores-screen');
        });
        helpBtn.addEventListener('click', () => switchScreen('help-screen'));
        creditsBtn.addEventListener('click', () => switchScreen('credits-screen'));
        
        helpBackBtn.addEventListener('click', () => switchScreen('main-menu'));
        creditsBackBtn.addEventListener('click', () => switchScreen('main-menu'));
        highScoresBackBtn.addEventListener('click', () => switchScreen('main-menu'));
        endGameBackToMenuBtn.addEventListener('click', () => {
            if (highScoreInputArea.style.display === 'block' && !scoreSubmitted) {
                highScoreInputArea.style.display = 'none'; 
            }
            switchScreen('main-menu');
        });

        // --- In-Game Event Listeners ---
        canvas.addEventListener('click', (event) => {
            if (gameState === 'PLAYING') placeTower(event);
        });
        canvas.addEventListener('mousemove', (event) => {
            if (gameState === 'PLAYING' && selectedTowerType && !gameOver && !gameWon) {
                ctx.clearRect(0,0,canvas.width, canvas.height); 
                drawPath(); drawGrid(); drawTowers(); drawEnemies(); drawProjectiles(); 
                drawPlacementPreview(event);
            }
        });
         canvas.addEventListener('mouseleave', () => {
            if (gameState === 'PLAYING' && selectedTowerType && !gameOver && !gameWon) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawPath(); drawGrid(); drawTowers(); drawEnemies(); drawProjectiles();
            }
        });
        document.querySelectorAll('.tower-button').forEach(button => {
            button.addEventListener('click', () => {
                if (gameState === 'PLAYING') {
                    initAudio(); const type = button.dataset.type;
                    selectedTowerType = (selectedTowerType === type) ? null : type;
                    updateUI(); 
                }
            });
        });
        startWaveButton.addEventListener('click', () => {
            if (gameState === 'PLAYING') {
                initAudio(); startNextWave();
            }
        });

        // --- Initial Setup ---
        switchScreen('main-menu');

    </script>
</body>
</html>