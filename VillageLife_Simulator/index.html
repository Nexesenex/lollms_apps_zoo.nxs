<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Village Life Simulator - Enhanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Ensure lollms_client.js is served correctly -->
    <script src="/lollms_assets/js/lollms_client_js"></script> 
    <!-- Axios might not be strictly necessary if lollms_client handles HTTP, but keep if used -->
    <!-- <script src="/lollms_assets/js/axios.min.js"></script> --> 
    <script src="https://unpkg.com/panzoom@9.4.0/dist/panzoom.min.js"></script>
    <style>
        /* Custom styles for better visuals */
        .villager-icon {
            transition: left 1.5s ease-in-out, top 1.5s ease-in-out, background-color 0.5s ease;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        .villager-icon:hover {
            transform: scale(1.1);
            z-index: 10; /* Bring to front on hover */
        }
        .location-icon {
            transition: transform 0.2s ease-in-out;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            border: 1px solid rgba(0,0,0,0.2);
        }
        .location-icon:hover {
            transform: scale(1.05);
            border-color: #fff;
        }
        /* Day/Night cycle effect */
        #villageMapContainer.day { background-color: #a8dadc; transition: background-color 2s ease-in-out;} /* Light Blue Day */
        #villageMapContainer.night { background-color: #1d3557; transition: background-color 2s ease-in-out;} /* Dark Blue Night */

        /* Scrollbar styling for panels */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #4a5568; /* gray-600 */
            border-radius: 10px;
            border: 2px solid #2d3748; /* gray-800 */
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background-color: #718096; /* gray-500 */
        }
        
        /* Style for console output */
         #consoleOutput {
             font-family: 'Courier New', Courier, monospace;
             background-color: #1a202c; /* darker gray */
             color: #9ae6b4; /* lighter green */
             padding: 0.5rem;
             border-radius: 0.25rem;
             max-height: 10rem; /* Limit height */
             overflow-y: auto;
             white-space: pre-wrap;
             word-wrap: break-word;
             font-size: 0.8rem;
             border: 1px solid #4a5568; /* gray-600 */
         }

    </style>
</head>
<body class="bg-gray-900 text-white font-sans overflow-hidden">
    <div id="gameContainer" class="w-full h-screen relative flex">
        <!-- Left-side control panel -->
        <div id="controlPanel" class="w-72 bg-gray-800 bg-opacity-95 p-4 overflow-y-auto custom-scrollbar transform -translate-x-full transition-transform duration-300 ease-in-out absolute left-0 top-0 bottom-0 z-20 shadow-xl">
            <h2 class="text-2xl font-semibold mb-4 text-cyan-400 border-b border-cyan-700 pb-2">Controls</h2>
            <div class="space-y-4">
                <div>
                    <label for="numPlaces" class="text-sm font-medium text-gray-300">Number of Places:</label>
                    <input type="number" id="numPlaces" min="3" max="25" value="10" class="mt-1 w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500">
                </div>
                <div>
                    <label for="numPersonas" class="text-sm font-medium text-gray-300">Number of Personas:</label>
                    <input type="number" id="numPersonas" min="2" max="30" value="5" class="mt-1 w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500">
                </div>
                <div>
                    <label for="villageContext" class="text-sm font-medium text-gray-300">Village Context:</label>
                    <textarea id="villageContext" rows="4" class="mt-1 w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="e.g., A serene medieval fantasy village nestled by a shimmering lake..."></textarea>
                </div>
                <div>
                    <label for="maxSteps" class="text-sm font-medium text-gray-300">Max Simulation Steps:</label>
                    <input type="number" id="maxSteps" min="1" max="1000" value="100" class="mt-1 w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500">
                </div>
                <div class="flex items-center mt-2">
                    <input type="checkbox" id="buildImages" class="form-checkbox h-4 w-4 text-cyan-500 bg-gray-700 border-gray-600 rounded focus:ring-cyan-600" disabled>
                    <label for="buildImages" class="ml-2 text-sm font-medium text-gray-500">(Image Gen Coming Soon)</label>
                </div>
                <button id="buildVillageBtn" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded transition duration-300 shadow-md">
                    Build Village
                </button>
                <div class="pt-2">
                    <label for="speedControl" class="text-sm font-medium text-gray-300 block mb-1">Simulation Speed:</label>
                    <input type="range" id="speedControl" min="1" max="10" value="3" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg dark:bg-gray-600">
                    <div class="flex justify-between text-xs text-gray-400 mt-1">
                        <span>Slow</span>
                        <span>Fast</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main game area -->
        <div class="flex-grow relative">
            <div id="villageMapContainer" class="w-full h-full day"> <!-- Start with day class -->
                <!-- VillageMap content will be added dynamically -->
                <div id="villageMap" class="w-full h-full relative cursor-grab"></div> 
            </div>
            <!-- Time of Day Indicator -->
            <div id="timeIndicator" class="absolute top-4 right-4 bg-black bg-opacity-50 text-white text-sm px-3 py-1 rounded-full shadow-lg">
                ☀️ Day
            </div>
        </div>

        <!-- Bottom panels (Character & Event) -->
        <div id="bottomPanelsContainer" class="absolute inset-x-0 bottom-16 z-10 pointer-events-none"> 
            <div id="characterPanel" class="hidden absolute bottom-0 left-0 right-0 bg-gray-800 bg-opacity-95 p-4 overflow-y-auto custom-scrollbar max-h-[40vh] pointer-events-auto shadow-inner rounded-t-lg">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xl font-semibold text-green-400">Characters</h2>
                    <button id="closeCharPanelBtn" class="text-gray-400 hover:text-white text-2xl">×</button>
                </div>
                <div id="characterInfo" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"></div>
            </div>

            <div id="eventPanel" class="hidden absolute bottom-0 left-0 right-0 bg-gray-800 bg-opacity-95 p-4 overflow-y-auto custom-scrollbar max-h-[40vh] pointer-events-auto shadow-inner rounded-t-lg">
                 <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xl font-semibold text-yellow-400">Event Log</h2>
                    <button id="closeEventPanelBtn" class="text-gray-400 hover:text-white text-2xl">×</button>
                </div>
                <div id="eventLogContainer" class="h-64">
                    <div id="eventLog" class="space-y-2"></div>
                </div>
            </div>
        </div>
        
        <!-- Loading Overlay -->
        <div id="loadingOverlay" class="hidden absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-6 rounded-lg shadow-xl max-w-lg w-full">
                <div class="flex items-center mb-4">
                    <div class="animate-spin rounded-full h-8 w-8 border-t-4 border-cyan-500 border-solid mr-3"></div>
                    <h3 id="loadingMessage" class="text-lg font-semibold text-cyan-400">Processing...</h3>
                </div>
                <div class="bg-gray-900 p-3 rounded border border-gray-700 mb-4">
                    <pre id="consoleOutput" class="text-cyan-300 font-mono text-sm overflow-y-auto max-h-40 whitespace-pre-wrap break-words custom-scrollbar"></pre>
                </div>
                <button id="pauseBtn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition duration-300">
                    Cancel Generation
                </button>
            </div>
        </div>

        <!-- Bottom menu bar -->
        <div class="absolute bottom-0 inset-x-0 bg-gray-800 bg-opacity-95 p-3 flex justify-between items-center z-20 shadow-lg border-t border-gray-700">
            <!-- Left Buttons -->
            <div class="flex space-x-3">
                <button id="controlsBtn" title="Toggle Controls" class="flex items-center bg-blue-600 hover:bg-blue-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                </button>
                <button id="charactersBtn" title="Show Characters" class="flex items-center bg-green-600 hover:bg-green-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                </button>
                <button id="eventLogBtn" title="Show Event Log" class="flex items-center bg-yellow-600 hover:bg-yellow-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
                </button>
            </div>
            <!-- Center Buttons -->
            <div class="flex space-x-3">
                 <button id="exportBtn" title="Export State" class="flex items-center bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                </button>
                <button id="importBtn" title="Import State" class="flex items-center bg-purple-600 hover:bg-purple-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                </button>
                 <button id="buildStoryBtn" title="Build Story from Events" class="flex items-center bg-pink-600 hover:bg-pink-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg>
                </button>
            </div>
             <!-- Right Button -->
            <div class="flex space-x-4">
                <button id="startPauseBtn" class="flex items-center bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition duration-300 transform hover:scale-105 shadow-md min-w-[180px] justify-center">
                    <svg id="startIcon" class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <svg id="pauseIcon" class="w-5 h-5 mr-2 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <span id="startPauseText">Start Simulation</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Global Variables & State ---
        const villageMapElement = document.getElementById('villageMap');
        const villageMapContainer = document.getElementById('villageMapContainer');
        const controlPanel = document.getElementById('controlPanel');
        const characterPanel = document.getElementById('characterPanel');
        const eventPanel = document.getElementById('eventPanel');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const consoleOutput = document.getElementById('consoleOutput');
        const startPauseBtn = document.getElementById('startPauseBtn');
        const startPauseText = document.getElementById('startPauseText');
        const startIcon = document.getElementById('startIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const timeIndicator = document.getElementById('timeIndicator');
        const characterInfoDiv = document.getElementById('characterInfo');
        const eventLogDiv = document.getElementById('eventLog');


        let lc = null; // Initialize later
        let simulationRunning = false;
        let villagers = [];
        let locations = [];
        let events = [];
        let currentStep = 0;
        let maxSimulationSteps = 100;
        let dayTime = 'day'; // 'day' or 'night'
        let stepsPerDay = 20; // How many simulation steps before toggling day/night
        let animationFrameId = null;
        let simulationSpeed = 3; // Default speed value (maps to timeout delay)
        let generationInProgress = false; // Flag to prevent multiple generations at once
        
        // --- Panzoom Initialization ---
        let panzoomInstance = null;
         try {
             panzoomInstance = panzoom(villageMapElement, {
                 maxZoom: 4,
                 minZoom: 0.4,
                 bounds: true,
                 boundsPadding: 0.1,
                 smoothScroll: false, // Can help performance
                 enableTextSelection: false,
             });
         } catch (error) {
             console.error("Panzoom initialization failed:", error);
         }

        // --- Lollms Initialization ---
        function initializeLollmsClient() {
             try {
                 lc = new LollmsClient(window.location.origin, ()=>{console.log("Lollms Client connected")}, ()=>{console.error("Lollms Client connection failed")});
                 console.log("Lollms Client initialized.");
             } catch (error) {
                 console.error("Failed to initialize LollmsClient:", error);
                 alert("Error initializing Lollms Client. Please ensure the client script is loaded correctly and the server is running.");
             }
        }

        // --- Utility Functions ---
        function shuffleArray(array) { /* ... (same as before) ... */ }
        function lerp(start, end, amount) { return start + (end - start) * amount; }
        function appendToConsole(text) {
            if (consoleOutput) {
                consoleOutput.textContent += (consoleOutput.textContent ? '\n' : '') + `> ${text}`;
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            } else {
                console.warn("Console output element not found.");
            }
        }
        function showLoader(message = "Processing...") {
            if (loadingMessage) loadingMessage.textContent = message;
            if (loadingOverlay) loadingOverlay.classList.remove('hidden');
            generationInProgress = true; // Set generation flag
        }
        function hideLoader() {
            if (loadingOverlay) loadingOverlay.classList.add('hidden');
            generationInProgress = false; // Clear generation flag
        }
        function safeJsonParse(jsonString, defaultValue = null) {
            try {
                // Attempt to remove potential markdown code fences
                const cleanedString = jsonString.replace(/```json\n?([\s\S]*?)\n?```/g, '$1').trim();
                return JSON.parse(cleanedString);
            } catch (error) {
                console.error("JSON Parsing Error:", error);
                console.error("Original String:", jsonString);
                appendToConsole(`Error parsing LLM response: ${error.message}`);
                return defaultValue;
            }
        }

        // --- Parameter Saving/Loading ---
        function saveParameters() { /* ... (same as before) ... */ }
        function loadParameters() { /* ... (same as before) ... */ }

        // --- LLM Generation Functions ---
        async function generateLocation(villageContext, existingLocations, retryCount = 0) {
            if (!lc) { appendToConsole("LLM client not ready."); return null; }
            if (generationInProgress) return null; // Prevent overlap

            appendToConsole('Generating location...');
            const existingLocationNames = existingLocations.map(l => l.name).join(", ");
            // Simplified prompt focusing on uniqueness and type
            const prompt = `${lc.system_message()}Generate a unique village location as a JSON object.
Context: ${villageContext}.
Existing locations to avoid: ${existingLocationNames}.
Required fields: name (string, UNIQUE), type (string, e.g., 'House', 'Shop', 'Tavern', 'Farm', 'Forest', 'Mine', 'Market', 'Temple'), description (string, brief).

Example JSON format:
\`\`\`json
{
    "name": "The Cracking Cauldron",
    "type": "Shop",
    "description": "An apothecary selling strange potions and bubbling concoctions."
}
\`\`\`
${lc.user_message()}Generate one NEW, UNIQUE location, different from: ${existingLocationNames}.${lc.ai_message()}`;
            
            showLoader(`Generating location ${existingLocations.length + 1}...`);
            try {
                const locationJson = await lc.generateCode(prompt);
                if (locationJson) {
                    const newLocation = safeJsonParse(locationJson);
                    if (!newLocation || !newLocation.name || !newLocation.type || !newLocation.description) {
                         throw new Error("Invalid location format received.");
                    }
                    
                    if (existingLocations.some(loc => loc.name.toLowerCase() === newLocation.name.toLowerCase())) {
                         if (retryCount < 2) { // Increased retries
                            console.warn(`Location name "${newLocation.name}" exists. Retrying (${retryCount + 1})...`);
                            appendToConsole(`Location name "${newLocation.name}" exists. Retrying...`);
                            return generateLocation(villageContext, existingLocations, retryCount + 1);
                        } else {
                            console.error("Failed to generate unique location name after retries.");
                            appendToConsole("Error: Could not generate a unique location name.");
                            // Assign a placeholder if retries fail
                             newLocation.name = `Unique Location ${Date.now()}`;
                             appendToConsole(`Assigned placeholder name: ${newLocation.name}`);
                        }
                    }
                     // Assign visual coordinates based on type or grid (simplified)
                    const gridCols = 5;
                    const index = existingLocations.length;
                    newLocation.x = 10 + (index % gridCols) * 18 + Math.random()*4-2; // Add some randomness
                    newLocation.y = 10 + Math.floor(index / gridCols) * 20 + Math.random()*4-2;
                    newLocation.icon = getLocationIcon(newLocation.type); // Get icon based on type
                    
                    appendToConsole(`Added ${newLocation.name} (${newLocation.type})`);
                    hideLoader();
                    return newLocation;
                }
            } catch (error) {
                 console.error("Error generating location:", error);
                 appendToConsole(`Error generating location: ${error.message}`);
            }
            hideLoader();
            return null;
        }

         async function generateVillager(villageContext, existingVillagers, locations) {
             if (!lc) { appendToConsole("LLM client not ready."); return null; }
             if (generationInProgress) return null;

             appendToConsole('Generating villager...');
             const existingVillagerNames = existingVillagers.map(v => v.name).join(", ");
             const locationNames = locations.map(l => l.name);
             const randomStartLocation = locationNames[Math.floor(Math.random() * locationNames.length)] || "Village Square"; // Fallback

             const prompt = `${lc.system_message()}Generate a unique villager as a JSON object for a simulation.
Context: ${villageContext}.
Existing villagers to avoid: ${existingVillagerNames}.
Available locations: ${locationNames.join(", ")}.
Required fields: name (string, UNIQUE), gender (string, 'male' or 'female'), age (number, 15-80), occupation (string), personalityTraits (array of 3 strings), currentStatus { location (string, must be from available locations), activity (string), mood (string) }, backstory (string, brief).

Example JSON format:
\`\`\`json
{
    "name": "Bram Stoutheart",
    "gender": "male",
    "age": 45,
    "occupation": "Blacksmith",
    "personalityTraits": ["gruff", "reliable", "secretly kind"],
    "currentStatus": {
        "location": "The Forge",
        "activity": "Hammering metal",
        "mood": "Focused"
    },
    "backstory": "Took over the family forge after his father. Known for his strong arms and quality work, though not his conversation skills."
}
\`\`\`
${lc.user_message()}Generate one NEW, UNIQUE villager, different from: ${existingVillagerNames}. Start location must be one of: ${locationNames.join(", ")}.${lc.ai_message()}`;

             showLoader(`Generating villager ${existingVillagers.length + 1}...`);
             try {
                const villagerJson = await lc.generateCode(prompt);
                 if (villagerJson) {
                     const villager = safeJsonParse(villagerJson);
                     if (!villager || !villager.name || !villager.gender || !villager.age || !villager.currentStatus || !villager.currentStatus.location) {
                          throw new Error("Invalid villager format received.");
                     }

                    if (existingVillagers.some(v => v.name.toLowerCase() === villager.name.toLowerCase())) {
                         // Handle name collision simply by appending a number or retrying if needed
                         villager.name = `${villager.name} II`; 
                         appendToConsole(`Villager name collision, adjusted to ${villager.name}`);
                    }
                    
                    // Ensure starting location is valid
                    if (!locationNames.includes(villager.currentStatus.location)) {
                        villager.currentStatus.location = randomStartLocation;
                        appendToConsole(`Adjusted ${villager.name}'s start location to ${randomStartLocation}`);
                    }

                     villager.relationships = {}; // Initialize relationships
                     villager.newMemories = []; // Initialize memory array
                     villager.thoughts = "";    // Initialize thoughts
                     // Assign initial visual position based on start location
                     const startLoc = locations.find(loc => loc.name === villager.currentStatus.location);
                     villager.visualX = startLoc ? startLoc.x + Math.random()*2-1 : 50; // Add jitter
                     villager.visualY = startLoc ? startLoc.y + Math.random()*2-1 : 50;
                     villager.targetX = villager.visualX; // Initially at target
                     villager.targetY = villager.visualY;
                     villager.icon = villager.gender === 'male' ? '🧑' : '👩'; // Simple default icon

                     // Initialize relationships with existing villagers
                     existingVillagers.forEach(otherVillager => {
                         if (villager.name !== otherVillager.name) {
                             villager.relationships[otherVillager.name] = { affinity: Math.floor(Math.random() * 60) + 20, interactions: 0 }; // Start neutral-ish
                             if (!otherVillager.relationships) otherVillager.relationships = {}; // Ensure other has relationships object
                             otherVillager.relationships[villager.name] = { affinity: Math.floor(Math.random() * 60) + 20, interactions: 0 };
                         }
                     });

                     appendToConsole(`Added ${villager.name} (${villager.occupation})`);
                     hideLoader();
                     return villager;
                 }
             } catch (error) {
                 console.error("Error generating villager:", error);
                 appendToConsole(`Error generating villager: ${error.message}`);
             }
             hideLoader();
             return null;
         }

        async function updateVillagerStatus(villager, currentStep, dayTime) {
             if (!lc) { appendToConsole("LLM client not ready."); return villager; }
             if (generationInProgress) return villager;

             const villageContext = document.getElementById('villageContext').value || 'A typical village';
             const locationNames = locations.map(l => l.name);
             const otherVillagersBrief = villagers.filter(v => v.name !== villager.name).map(v => `${v.name} (${v.occupation}, mood: ${v.currentStatus.mood})`);

             // More detailed prompt asking for goal-oriented behavior
             const prompt = `${lc.system_message()}You are simulating a villager's AI. Based on their current state, personality, relationships, time of day, and village context, decide their next logical action, location, and mood. Update the 'currentStatus' field in JSON format. Keep activities appropriate for the time of day and location. The villager might interact with others present at the location (this will be handled separately). They should pursue goals related to their occupation, needs, or relationships.

Village Context: ${villageContext}
Time of Day: ${dayTime}
Current Step: ${currentStep}
Available Locations: ${locationNames.join(", ")}
Other Villagers (brief): ${otherVillagersBrief.join("; ") || 'None nearby'}

Villager Details: ${JSON.stringify(villager, (key, value) => key === 'relationships' ? undefined : value)} 
**(Do not include 'relationships' in the output)**

Output only the updated JSON object for 'currentStatus'. Ensure 'location' is chosen from the available locations.

Example Output Format:
\`\`\`json
{
    "location": "Market Square",
    "activity": "Trading herbs for supplies",
    "mood": "Content"
}
\`\`\`
${lc.user_message()}Update the status for ${villager.name}. Current Status: ${JSON.stringify(villager.currentStatus)}. Backstory: ${villager.backstory}. Personality: ${villager.personalityTraits.join(', ')}.${lc.ai_message()}`;

            // Do not show loader for individual status updates to keep simulation smooth
             // showLoader(`Updating ${villager.name}...`); 
             try {
                const updatedStatusJson = await lc.generateCode(prompt);
                 if (updatedStatusJson) {
                     const updatedStatus = safeJsonParse(updatedStatusJson);
                     if (updatedStatus && updatedStatus.location && updatedStatus.activity && updatedStatus.mood) {
                         // Validate location
                         if (!locationNames.includes(updatedStatus.location)) {
                             console.warn(`LLM suggested invalid location "${updatedStatus.location}" for ${villager.name}. Keeping previous: ${villager.currentStatus.location}`);
                             updatedStatus.location = villager.currentStatus.location; // Revert to old location
                         }
                        // appendToConsole(`${villager.name} -> ${updatedStatus.activity} at ${updatedStatus.location} (${updatedStatus.mood})`);
                        return { ...villager, currentStatus: updatedStatus };
                    } else {
                         console.warn(`Invalid status format received for ${villager.name}:`, updatedStatusJson);
                         appendToConsole(`Received invalid status update for ${villager.name}.`);
                    }
                 }
             } catch (error) {
                 console.error(`Error updating ${villager.name}:`, error);
                 appendToConsole(`Error updating ${villager.name}: ${error.message}`);
             }
             // hideLoader();
             return villager; // Return original villager if update fails
         }

        async function generateGroupInteraction(participants) {
             if (!lc) { appendToConsole("LLM client not ready."); return null; }
             if (participants.length < 2) return null;
             if (generationInProgress) return null;

             const villageContext = document.getElementById('villageContext').value || 'A simple village';
             const participantDetails = participants.map(p => ({
                 name: p.name,
                 occupation: p.occupation,
                 mood: p.currentStatus.mood,
                 personality: p.personalityTraits,
                 // Include affinities *within the group*
                 affinities: Object.fromEntries(
                     participants
                         .filter(other => other.name !== p.name)
                         .map(other => [other.name, p.relationships[other.name]?.affinity || 50])
                 )
             }));

             // Prompt focusing on dialogue and outcome based on affinities/personalities
             const prompt = `${lc.system_message()}Simulate a realistic interaction between these villagers who are currently at the same location. Generate dialogue and outcomes (mood changes, affinity changes, new memories) based on their personalities, occupations, current moods, and mutual affinities. The interaction should feel natural for the village context.

Village Context: ${villageContext}
Time of Day: ${dayTime}
Participants & Their State:
${JSON.stringify(participantDetails, null, 2)}

Output a JSON object describing the interaction. Include 'type' (e.g., "Casual Chat", "Argument", "Trading Goods", "Sharing News"), 'dialogue' (array of {speaker, text}), and 'outcomes' (object keyed by villager name, containing optional 'moodChange', 'affinityChanges' {otherName: change}, 'newMemories' [array of strings]). Affinity changes should be relative (-10 to +10).

Example Output Format:
\`\`\`json
{
    "type": "Trading Goods",
    "dialogue": [
        {"speaker": "Bram", "text": "Need that horseshoe fixed, Elara?"},
        {"speaker": "Elara", "text": "Yes, Bram. And I brought you some soothing tea for that cough."},
        {"speaker": "Bram", "text": "Hmph. Thanks. That'll be two silvers for the shoe."},
        {"speaker": "Elara", "text": "Fair enough. Always appreciate your work."}
    ],
    "outcomes": {
        "Bram": {
            "moodChange": "Slightly Less Gruff",
            "affinityChanges": {"Elara": 2},
            "newMemories": ["Fixed Elara's horseshoe.", "Received some decent tea."]
        },
        "Elara": {
            "moodChange": "Pleased",
            "affinityChanges": {"Bram": 3},
            "newMemories": ["Successfully traded tea for blacksmithing.", "Bram seemed to like the tea."]
        }
    }
}
\`\`\`
${lc.user_message()}Generate an interaction for the participants listed above.${lc.ai_message()}`;

            // showLoader("Generating interaction..."); // Maybe too frequent?
            try {
                const interactionJson = await lc.generateCode(prompt);
                if (interactionJson) {
                    const interaction = safeJsonParse(interactionJson);
                    if (interaction && interaction.type && interaction.dialogue && interaction.outcomes) {
                        updateGroupRelationships(participants, interaction); // Apply changes
                        // appendToConsole(`Interaction: ${interaction.type} between ${participants.map(p=>p.name).join(', ')}`);
                        return interaction;
                    } else {
                         console.warn("Invalid interaction format:", interactionJson);
                         appendToConsole("Received invalid interaction format from LLM.");
                    }
                }
            } catch (error) {
                 console.error("Error generating interaction:", error);
                 appendToConsole(`Error generating interaction: ${error.message}`);
            }
            // hideLoader();
             return null;
         }
        
        function updateGroupRelationships(participants, interaction) {
            if (!interaction.outcomes) return;

            for (const villager of participants) {
                const outcome = interaction.outcomes[villager.name];
                if (outcome) {
                    if (outcome.moodChange) villager.currentStatus.mood = outcome.moodChange;
                    
                    if (outcome.affinityChanges) {
                        for (const [otherName, change] of Object.entries(outcome.affinityChanges)) {
                            if (villager.relationships[otherName] && typeof change === 'number') {
                                villager.relationships[otherName].affinity = Math.max(0, Math.min(100, villager.relationships[otherName].affinity + change));
                                villager.relationships[otherName].interactions++;
                                // Also update the other person's relationship towards this villager if mentioned
                                const otherVillager = participants.find(p => p.name === otherName);
                                if (otherVillager && otherVillager.relationships[villager.name]) {
                                     // We assume the LLM gives changes FROM the perspective of the key villager
                                     // If we want reciprocal changes, the LLM needs to specify both, or we estimate
                                     // For simplicity, only update based on the specified outcome's affinityChanges
                                }
                            }
                        }
                    }
                    if (outcome.newMemories && Array.isArray(outcome.newMemories)) {
                        if (!villager.newMemories) villager.newMemories = [];
                        villager.newMemories.push(...outcome.newMemories);
                        villager.newMemories = villager.newMemories.slice(-10); // Keep last 10 memories
                    }
                     if (outcome.thoughts) { // If LLM provides thoughts
                         villager.thoughts = outcome.thoughts;
                     }
                }
            }
        }
        
        // --- Simulation Loop & Steps ---
        async function runSimulation() {
            if (!simulationRunning || generationInProgress) return; // Don't run if paused or generating

            await simulationStep();

            if (simulationRunning && currentStep < maxSimulationSteps) {
                // Calculate delay based on speed control (higher value = faster)
                const speedValue = parseInt(document.getElementById('speedControl').value) || 3;
                const delay = 6000 / speedValue; // Adjust base delay (6000ms = 6s)
                setTimeout(runSimulation, delay);
            } else if (currentStep >= maxSimulationSteps) {
                simulationRunning = false;
                 if (startPauseBtn) {
                     startPauseText.textContent = 'Simulation Complete';
                     startIcon.classList.remove('hidden');
                     pauseIcon.classList.add('hidden');
                     startPauseBtn.classList.replace('bg-red-600','bg-gray-600');
                     startPauseBtn.classList.replace('hover:bg-red-700','hover:bg-gray-700');
                     startPauseBtn.disabled = true; // Disable button after completion
                 }
                appendToConsole('Simulation reached maximum steps.');
                alert('Simulation has reached the maximum number of steps.');
                 hideLoader(); // Ensure loader is hidden
            }
        }

        async function simulationStep() {
            if(generationInProgress) return; // Don't step while generating initial village

            currentStep++;
            appendToConsole(`--- Step ${currentStep} (${dayTime}) ---`);
            showLoader(`Simulating step ${currentStep}/${maxSimulationSteps}...`);

            // 1. Update Villager Statuses & Target Positions
            const statusUpdatePromises = villagers.map(v => updateVillagerStatus(v, currentStep, dayTime));
            const updatedVillagers = await Promise.all(statusUpdatePromises);
            villagers = updatedVillagers; // Update the global state

            villagers.forEach(villager => {
                const targetLoc = locations.find(loc => loc.name === villager.currentStatus.location);
                if (targetLoc) {
                    villager.targetX = targetLoc.x + Math.random()*2-1; // Target location with jitter
                    villager.targetY = targetLoc.y + Math.random()*2-1;
                } else {
                    console.warn(`Target location "${villager.currentStatus.location}" not found for ${villager.name}. Staying put.`);
                    villager.targetX = villager.visualX; // Stay put if location invalid
                    villager.targetY = villager.visualY;
                }
            });

            // 2. Group Villagers by Location for Interaction
            const villagersByLocation = {};
            villagers.forEach(v => {
                if (!villagersByLocation[v.currentStatus.location]) {
                    villagersByLocation[v.currentStatus.location] = [];
                }
                villagersByLocation[v.currentStatus.location].push(v);
            });

            // 3. Generate Interactions for groups of 2+
            const interactionPromises = [];
            for (const locationName in villagersByLocation) {
                const group = villagersByLocation[locationName];
                if (group.length >= 2) {
                    // Decide if an interaction happens (maybe not every step for every group)
                    if (Math.random() < 0.6) { // 60% chance of interaction for groups
                         interactionPromises.push(generateGroupInteraction(group));
                    }
                }
            }
            
            const interactionResults = await Promise.all(interactionPromises);
            interactionResults.forEach(interaction => {
                if (interaction) {
                    const participantNames = Object.keys(interaction.outcomes); // Names are keys in outcomes
                    const event = {
                        type: 'interaction',
                        title: `Interaction: ${interaction.type}`,
                        description: `${participantNames.join(', ')} at ${villagers.find(v=>v.name === participantNames[0])?.currentStatus?.location || 'Unknown Location'}: "${interaction.dialogue[0]?.text || '(Action/Observation)'}"`,
                        details: `Outcome Summary: ${participantNames.map(name => interaction.outcomes[name]?.moodChange || 'no mood change').join('; ')}`,
                        interaction: interaction // Store full interaction data
                    };
                    events.push(event);
                    addEventToLog(event);
                }
            });

            // 4. Update Day/Night Cycle
            if (currentStep % stepsPerDay === 0) {
                dayTime = dayTime === 'day' ? 'night' : 'day';
                appendToConsole(`Time changed to ${dayTime}.`);
                 if(timeIndicator){
                    timeIndicator.textContent = dayTime === 'day' ? '☀️ Day' : '🌙 Night';
                    villageMapContainer.classList.toggle('day', dayTime === 'day');
                    villageMapContainer.classList.toggle('night', dayTime === 'night');
                 }
            }

            // 5. Update UI (Character info needs latest state after interactions)
            updateCharacterInfo(); // Update character panel with latest moods, etc.
             // Visual map update happens in the animate loop now

            hideLoader();
        }

        // --- Visual Updates & Map ---
        function getLocationIcon(type) {
             switch (type?.toLowerCase()) {
                 case 'house': case 'home': case 'residence': return '🏠';
                 case 'shop': case 'store': case 'market stall': return '🛒';
                 case 'tavern': case 'inn': return '🍺';
                 case 'farm': return '🚜';
                 case 'forest': case 'grove': case 'woods': return '🌳';
                 case 'mine': return '⛏️';
                 case 'market': case 'square': case 'plaza': return '🏛️';
                 case 'temple': case 'shrine': case 'church': return '⛪';
                 case 'forge': case 'blacksmith': return '🔥';
                 case 'library': return '📚';
                 case 'field': return '🌾';
                 case 'lake': case 'river': case 'pond': return '💧';
                 default: return '📍'; 
             }
         }
        
        function updateVillageMap() {
            if (!villageMapElement) return;
            villageMapElement.innerHTML = ''; // Clear previous elements

            // Add Locations
            locations.forEach((location, index) => {
                const locationElement = document.createElement('div');
                locationElement.id = `location-${index}`;
                locationElement.className = 'location-icon absolute w-16 h-16 bg-yellow-200 rounded-lg flex flex-col items-center justify-center text-xs text-center text-black cursor-pointer p-1';
                locationElement.style.left = `${location.x}%`;
                locationElement.style.top = `${location.y}%`;
                // Prevent panzoom from capturing click events needed for details
                 locationElement.addEventListener('click', (e) => {
                     e.stopPropagation(); // Important to stop event bubbling to panzoom
                     showLocationDetails(location);
                 });
                locationElement.setAttribute('data-location-id', location.name); // Use name as ID
                 locationElement.innerHTML = `
                     <span class="text-2xl">${location.icon || '📍'}</span>
                     <span class="mt-1 truncate w-full">${location.name}</span>
                 `;
                villageMapElement.appendChild(locationElement);
            });

            // Add Villagers (or update existing ones)
            villagers.forEach((villager, index) => {
                let villagerElement = document.getElementById(`villager-${index}`);
                if (!villagerElement) {
                    villagerElement = document.createElement('div');
                    villagerElement.id = `villager-${index}`;
                    villagerElement.className = 'villager-icon absolute w-10 h-10 rounded-full flex items-center justify-center text-lg cursor-pointer font-bold';
                    villagerElement.setAttribute('data-villager-id', villager.name);
                    villagerElement.addEventListener('click', (e) => {
                         e.stopPropagation();
                         showVillagerHistory(villager);
                     });
                    villageMapElement.appendChild(villagerElement);
                }
                
                // Update visual properties (position is handled by animate loop)
                villagerElement.textContent = villager.icon || (villager.gender === 'male' ? '🧑' : '👩');
                villagerElement.title = `${villager.name} (${villager.currentStatus.mood})`; // Tooltip

                // Basic mood indicator via border color
                 let borderColor = 'border-gray-400'; // Default
                 if (villager.currentStatus.mood?.toLowerCase().includes('happy') || villager.currentStatus.mood?.toLowerCase().includes('excited') || villager.currentStatus.mood?.toLowerCase().includes('content')) {
                     borderColor = 'border-green-400';
                 } else if (villager.currentStatus.mood?.toLowerCase().includes('sad') || villager.currentStatus.mood?.toLowerCase().includes('angry') || villager.currentStatus.mood?.toLowerCase().includes('worried')) {
                     borderColor = 'border-red-400';
                 } else if (villager.currentStatus.mood?.toLowerCase().includes('focused') || villager.currentStatus.mood?.toLowerCase().includes('neutral')) {
                     borderColor = 'border-blue-400';
                 }
                 villagerElement.style.border = `2px solid ${borderColor.split('-')[1]}-${borderColor.split('-')[2]}`; // Apply border color dynamically
                 villagerElement.style.backgroundColor = villager.isSick ? '#DDA0DD' : (villager.gender === 'male' ? '#add8e6' : '#ffb6c1'); // Plum if sick, else gender color
            });
        }
        
        function animateVillagerMovement() {
             villagers.forEach((villager, index) => {
                 const villagerElement = document.getElementById(`villager-${index}`);
                 if (!villagerElement) return;

                 // Smoothly move towards target using lerp
                 const moveSpeed = 0.05; // Adjust for desired speed
                 villager.visualX = lerp(villager.visualX, villager.targetX, moveSpeed);
                 villager.visualY = lerp(villager.visualY, villager.targetY, moveSpeed);

                 // Apply the visual position
                 villagerElement.style.left = `${villager.visualX}%`;
                 villagerElement.style.top = `${villager.visualY}%`;
                 
                 // Update mood indicator (border color) - This could be less frequent
                 let borderColor = 'border-gray-400'; 
                 const moodLower = villager.currentStatus.mood?.toLowerCase() || '';
                 if (moodLower.includes('happy') || moodLower.includes('excited') || moodLower.includes('content') || moodLower.includes('pleased')) borderColor = 'border-green-400';
                 else if (moodLower.includes('sad') || moodLower.includes('angry') || moodLower.includes('worried')|| moodLower.includes('gruff')|| moodLower.includes('annoyed')) borderColor = 'border-red-400';
                 else if (moodLower.includes('focused') || moodLower.includes('neutral') || moodLower.includes('curious') || moodLower.includes('calm')) borderColor = 'border-blue-400';
                 
                 // Extract color value for direct style manipulation
                 const colorValue = borderColor === 'border-green-400' ? '#68D391' : 
                                    borderColor === 'border-red-400' ? '#FC8181' : 
                                    borderColor === 'border-blue-400' ? '#63B3ED' : '#A0AEC0';
                                    
                 villagerElement.style.borderColor = colorValue;
                 villagerElement.style.backgroundColor = gameState.isSick ? '#DDA0DD' : (villager.gender === 'male' ? '#add8e6' : '#ffb6c1'); // Sick color override
             });
         }


        function animate(timestamp) {
            if (gameState.isGameOver) { 
                 if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null;
                 return; // Stop animation if game over
             }
            
            animationFrameId = requestAnimationFrame(animate); // Request next frame first
            const deltaTime = timestamp - lastFrameTime;

            if (deltaTime > animationInterval) { // Update visuals at target FPS
                lastFrameTime = timestamp - (deltaTime % animationInterval);
                currentPetAnimationFrame = (currentPetAnimationFrame + 1) % 2; // Used by potential future detailed anims

                if (simulationRunning || !villagers.length ) { // Only animate movement if sim is running or village exists
                     animateVillagerMovement();
                }
            }
        }
        
        // --- UI Updates & Panels ---
        function updateCharacterInfo() {
            if (!characterInfoDiv) return;
            characterInfoDiv.innerHTML = '';

            villagers.forEach((villager, index) => {
                const villagerCard = document.createElement('div');
                villagerCard.className = 'bg-gray-700 border border-green-700 rounded-lg p-3 mb-3 font-mono text-sm text-green-300 shadow-md';
                let relationshipsHTML = '<ul class="list-disc pl-4 mt-2 text-xs">';
                for (const name in villager.relationships) {
                    const rel = villager.relationships[name];
                    const affinityColor = rel.affinity > 70 ? 'text-green-400' : rel.affinity < 30 ? 'text-red-400' : 'text-yellow-400';
                    relationshipsHTML += `<li>${name}: <span class="${affinityColor}">${rel.affinity}</span> (${rel.interactions} interactions)</li>`;
                }
                relationshipsHTML += '</ul>';

                villagerCard.innerHTML = `
                    <h3 class="font-semibold text-base text-green-200 mb-1">${villager.icon} ${villager.name}</h3>
                    <p>Age: <span class="text-white">${villager.age}</span> | Occ: <span class="text-white">${villager.occupation}</span></p>
                    <p>Status: <span class="text-white">${villager.currentStatus.activity}</span></p>
                    <p>At: <span class="text-white">${villager.currentStatus.location}</span></p>
                    <p>Mood: <span class="text-white">${villager.currentStatus.mood}</span></p>
                    <details class="mt-2 text-xs">
                        <summary class="cursor-pointer text-green-400 hover:text-green-200">Details</summary>
                        <p class="mt-1 text-gray-400">Traits: ${villager.personalityTraits.join(', ')}</p>
                        <p class="mt-1 text-gray-400">Backstory: ${villager.backstory}</p>
                        <p class="mt-1 text-gray-400">Thoughts: ${villager.thoughts || 'None'}</p>
                        <h4 class="font-semibold mt-2 text-green-400">Relationships:</h4>
                        ${relationshipsHTML}
                        <h4 class="font-semibold mt-2 text-green-400">Memories:</h4>
                        <ul class="list-disc pl-4 text-gray-400">${(villager.newMemories || []).map(m=>`<li>${m}</li>`).join('') || '<li>None</li>'}</ul>
                    </details>
                    <button class="mt-2 bg-blue-600 hover:bg-blue-500 text-white font-bold py-1 px-2 rounded text-xs edit-btn border border-blue-400" data-index="${index}">Edit</button>
                `;
                
                const editBtn = villagerCard.querySelector('.edit-btn');
                editBtn.addEventListener('click', (e) => {
                    const villagerIndex = parseInt(e.target.getAttribute('data-index'));
                    showEditVillagerModal(villagers[villagerIndex], villagerIndex);
                });

                characterInfoDiv.appendChild(villagerCard);
            });
        }
        
        function addEventToLog(event) {
            if (!eventLogDiv) return;
            const eventElement = document.createElement('div');
            // Simplified styling for better readability
            eventElement.className = 'bg-gray-700 border border-gray-600 rounded p-2 mb-2 text-xs text-gray-300 shadow'; 
            events.push(event); // Store event

            let interactionHtml = '';
            if (event.type === 'interaction' && event.interaction) { // Check if interaction data exists
                 interactionHtml = `<button class="mt-1 bg-gray-600 hover:bg-gray-500 text-white font-bold py-0.5 px-1.5 rounded text-xs show-interaction-btn border border-gray-500">Details</button>`;
            }
            
            eventElement.innerHTML = `
                <strong class="text-yellow-400">${event.title || 'Event'} (Step ${currentStep}):</strong>
                <p class="text-gray-200">${event.description}</p>
                ${event.details ? `<p class="mt-1 text-xs text-gray-400">${event.details}</p>` : ''}
                ${interactionHtml}
            `;
            
            if (event.type === 'interaction' && event.interaction) {
                const showInteractionBtn = eventElement.querySelector('.show-interaction-btn');
                showInteractionBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent potential panel closing
                    showInteractionPopup(event.interaction);
                 });
            }
            
            eventLogDiv.insertBefore(eventElement, eventLogDiv.firstChild); // Add new events to the top
            // Limit log length
            while (eventLogDiv.children.length > 100) {
                eventLogDiv.removeChild(eventLogDiv.lastChild);
            }
        }

        function showLocationDetails(location) { /* ... (same as before) ... */ }
        function showInteractionPopup(interaction) { /* ... (same as before, maybe improve styling) ... */ }
        function showVillagerHistory(villager) { /* ... (same as before, maybe improve styling) ... */ }
        function showEditVillagerModal(villager, index) { /* ... (same as before) ... */ }

        // --- UI Toggle Logic ---
        function togglePanel(panelToShow) {
            const panels = [controlPanel, characterPanel, eventPanel];
            panels.forEach(panel => {
                if (panel === panelToShow) {
                     if (panel === controlPanel) panel.classList.remove('-translate-x-full');
                     else panel.classList.remove('hidden');
                } else {
                     if (panel === controlPanel) panel.classList.add('-translate-x-full');
                     else panel.classList.add('hidden');
                }
            });
        }

        // --- Event Listeners ---
        document.getElementById('controlsBtn').addEventListener('click', () => togglePanel(controlPanel));
        document.getElementById('charactersBtn').addEventListener('click', () => togglePanel(characterPanel));
        document.getElementById('eventLogBtn').addEventListener('click', () => togglePanel(eventPanel));
        document.getElementById('closeCharPanelBtn')?.addEventListener('click', () => characterPanel.classList.add('hidden'));
        document.getElementById('closeEventPanelBtn')?.addEventListener('click', () => eventPanel.classList.add('hidden'));

        document.getElementById('buildVillageBtn').addEventListener('click', initializeSimulation);
        document.getElementById('startPauseBtn').addEventListener('click', () => {
            simulationRunning = !simulationRunning;
            if (simulationRunning) {
                startPauseText.textContent = 'Pause Simulation';
                startIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
                startPauseBtn.classList.replace('bg-red-600','bg-green-600');
                startPauseBtn.classList.replace('hover:bg-red-700','hover:bg-green-700');
                stepMode = false; // Ensure not in step mode
                if (currentStep >= maxSimulationSteps) currentStep = 0; // Reset if finished
                 maxSimulationSteps = parseInt(document.getElementById('maxSteps').value) || 100;
                runSimulation();
                appendToConsole("Simulation started.");
            } else {
                startPauseText.textContent = 'Start Simulation';
                startIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                startPauseBtn.classList.replace('bg-green-600','bg-red-600');
                startPauseBtn.classList.replace('hover:bg-green-700','hover:bg-red-700');
                 if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId=null; // Stop animation rendering immediately on pause
                 appendToConsole("Simulation paused.");
            }
        });
        
        document.getElementById('exportBtn').addEventListener('click', () => { /* ... (same as before) ... */ });
        document.getElementById('importBtn').addEventListener('click', () => { /* ... (same as before) ... */ });
        document.getElementById('buildStoryBtn')?.addEventListener('click', buildStoryBtn); // Add null check
        document.getElementById('pauseBtn').addEventListener('click', () => { // Cancel button in loader
            generationInProgress = false; // Allow hiding loader
            simulationRunning = false; // Stop simulation if it was running
            if (startPauseBtn) { // Reset start/pause button
                startPauseText.textContent = 'Start Simulation';
                startIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                startPauseBtn.classList.replace('bg-green-600','bg-red-600');
                startPauseBtn.classList.replace('hover:bg-green-700','hover:bg-red-700');
                startPauseBtn.disabled = false;
            }
            hideLoader();
            appendToConsole("Generation/Simulation Cancelled.");
            // Potentially clear partially generated data if needed
        });

        document.getElementById('speedControl').addEventListener('input', (event) => {
            simulationSpeed = parseInt(event.target.value);
            saveParameters(); // Save speed change
        });
        // Save parameters on change for other inputs
        ['numPlaces', 'numPersonas', 'villageContext', 'maxSteps'].forEach(id => {
             const el = document.getElementById(id);
             if(el) el.addEventListener('change', saveParameters);
        });

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            loadParameters(); // Load saved settings first
            initializeLollmsClient(); // Initialize connection to backend
            // Maybe add a slight delay or ready check for lc before enabling build button?
            // For now, assume it connects quickly.
            updateVillageMap(); // Draw empty map initially if needed
            // Simulation doesn't start automatically
        });
    </script>
</body>
</html>